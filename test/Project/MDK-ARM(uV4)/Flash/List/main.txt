; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\main.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User -I.\RTE\_Flash -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER ..\..\User\main.c]
                          THUMB

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;26     */
;;;27     int main(void)
000000  b508              PUSH     {r3,lr}
;;;28     {
;;;29     	/* 
;;;30     		51单片机的CPU主频直接有外部晶振决定，无需任何配置即可开始操作IO口。
;;;31     		而STM32功能强大，CPU主时钟选项很多，而且必须配置后才能正常工作。
;;;32     
;;;33     		不过幸运的是，在进入main()之前，ST固件库中的启动文件已经帮我们设置好了CPU时钟。
;;;34     		我们暂时可以不管它，直接开始我们的第一个应用：点亮开发板上的LED1指示灯(PF6 = 0 点亮LED1)
;;;35     	*/
;;;36     	
;;;37     	/* 
;;;38     		51单片机的IO口无需任何配置即可直接设置输出0和1。
;;;39     		STM32的GPIO有很多功能，可以关闭GPIO时钟降低功耗，可以设置为浮空输入、上拉输入、下拉输入、推挽输出、
;;;40     		开漏输出等多种工作模式，
;;;41     		CPU复位后，GPIO默认为GPIO时钟关闭和浮空输入，
;;;42     		因此我们需要使能GPIO时钟并配置GPIO为推挽输出模式，才能驱动LED
;;;43     	*/
;;;44     	
;;;45     	GPIO_InitTypeDef init;	/* 定义一个GPIO的结构体变量 */
;;;46     	/* 说明：GPIO_InitTypeDef 是ST固件库中定义的一个结构体变量类型
;;;47     		由于GPIO的参数很多，如果用函数形参设置每个参数，那么函数的形参太多了，因此ST使用了结构体变量，先
;;;48     		设置结构体变量每个成员的值，然后在执行GPIO设置
;;;49     	*/
;;;50     	
;;;51     	/* 打开GPIOF的时钟 */
;;;52     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOF, ENABLE);
000002  2101              MOVS     r1,#1
000004  2080              MOVS     r0,#0x80
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;53     
;;;54     	init.GPIO_Pin = GPIO_Pin_6;	/* 我们要控制的LED是PF6, 这个参数需要设置为	GPIO_Pin_6 (1个常量宏) */
00000a  2040              MOVS     r0,#0x40
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;55     	init.GPIO_Mode = GPIO_Mode_Out_PP;	/* 设置为输出推挽模式, Out表述Output，PP = Pull Push 推挽 */
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;56     	init.GPIO_Speed = GPIO_Speed_50MHz;	/* 设置GPIO工作的最大频率，降低速度可以抑制GPIO信号跳变沿的振铃现象 */
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;57     
;;;58     	/* 注意：之前的代码都是对CPU内部变量进行操作，还没有开始操作CPU的功能寄存器 */
;;;59     
;;;60     	/* GPIO_Init函数是ST固件库的函数，这一步将完成修改CPU寄存器的工作 
;;;61     		第1个参数 GPIOF 表示GPIO端口名，由于LED是PF6，位于GPIOF端口，因此此处是GPIOF 
;;;62     		第2个参数 &init 表示init结构体变量的指针
;;;63     	*/
;;;64     	GPIO_Init(GPIOF, &init); 
00001c  4669              MOV      r1,sp
00001e  4806              LDR      r0,|L1.56|
000020  f7fffffe          BL       GPIO_Init
;;;65     	/* 如果单步调试，执行完GPIO_Init()后，你会发现LED灯已经亮了。这是因为GPIO输出寄存器缺省是0，当切换到
;;;66     	输出模式时，会立刻输出0电平，对于安富莱STM32开发板，0电平表示点亮LED */
;;;67     
;;;68     	/* 调用这个函数设置 PF6 = 1 熄灭LED1 */		
;;;69     	GPIO_SetBits(GPIOF, GPIO_Pin_6);
000024  2140              MOVS     r1,#0x40
000026  4804              LDR      r0,|L1.56|
000028  f7fffffe          BL       GPIO_SetBits
;;;70     
;;;71     	/* 调用这个函数设置 PF6 = 0 点亮LED1 */
;;;72     	GPIO_ResetBits(GPIOF, GPIO_Pin_6);			
00002c  2140              MOVS     r1,#0x40
00002e  4802              LDR      r0,|L1.56|
000030  f7fffffe          BL       GPIO_ResetBits
;;;73     
;;;74     	while (1);	/* 一个死循环语句，程序停在此处 */
000034  bf00              NOP      
                  |L1.54|
000036  e7fe              B        |L1.54|
;;;75     
;;;76     	/* 通过这个例子，记住2点：
;;;77     	(1) 使用任何外设，均需要开启对应外设的时钟。固件库中有专门的函数 
;;;78     	(2) 使用GPIO前先使用GPIO_Init() 配置GPIO工作模式，除非您正好需要GPIO作为输入模式
;;;79     	*/
;;;80     }
                          ENDP

                  |L1.56|
                          DCD      0x40011c00

                  __ARM_use_no_argv EQU 0
